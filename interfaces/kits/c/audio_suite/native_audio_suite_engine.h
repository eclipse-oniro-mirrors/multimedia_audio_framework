/*
 * Copyright (c) 2025 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @addtogroup OHAudio
 * @{
 *
 * @brief Provide the definition of the C interface for the audio module.
 *
 * @syscap SystemCapability.Multimedia.Audio.Core
 *
 * @since 21
 * @version 1.0
 */

/**
 * @file native_audio_suite_engine.h
 *
 * @brief Declare audio suite engine related interfaces.
 *
 * This file interfaces are used for the creation of audioSuiteEngine
 * as well as creation of audioSuitePipeLine
 * as well as creation of audioSuiteNode
 *
 * @library libohaudio.so
 * @syscap SystemCapability.Multimedia.Audio.Core
 * @since 21
 * @version 1.0
 */

#ifndef NATIVE_AUDIO_SUITE_ENGINE_H
#define NATIVE_AUDIO_SUITE_ENGINE_H

#include "native_audio_suite_base.h"

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Request to create the audio engin.
 *
 * @param audioSuiteEngine created, which will be returned as the output parameter
 * @return {@link #AUDIOSUITE_SUCCESS} if execution succeeds
 * or {@link #AUDIOSUITE_ERROR_INVALID_PARAM} if audioSuiteEngine nullptr
 * or {@link #AUDIOSUITE_ERROR_ILLEGAL_STATE} if already create
 * @since 21
 */
OH_AudioSuite_Result OH_AudioSuiteEngine_Create(OH_AudioSuiteEngine** audioSuiteEngine);

/**
 * @brief Request to release the engine.
 *
 * @param audioSuiteEngine Reference generated by OH_AudioSuiteEngine_Create()
 * @return {@link #AUDIOSUITE_SUCCESS} if execution succeeds
 * or {@link #AUDIOSUITE_ERROR_INVALID_PARAM} if audioSuiteEngine nullptr
 * or {@link #AUDIOSUITE_ERROR_ILLEGAL_STATE} if not create
 * @since 21
 */
OH_AudioSuite_Result OH_AudioSuiteEngine_Destroy(OH_AudioSuiteEngine* audioSuiteEngine);

/**
 * @brief Request to create the pipeline. A pipeline is the smallest unit for executing audio suite,
 * and it must include at least one input node and one output node.
 *
 * @param audioSuiteEngine Reference generated by OH_AudioSuiteEngine_Create()
 * @param audioSuitePipeline Pointer to a viriable to receive the pipeline
 * which will be returned as the output parameter
 * @return {@link #AUDIOSUITE_SUCCESS} if execution succeeds
 * or {@link #AUDIOSUITE_ERROR_INVALID_PARAM} if parame nullptr
 * @since 21
 */
OH_AudioSuite_Result OH_AudioSuiteEngine_CreatePipeline(
    OH_AudioSuiteEngine* audioSuiteEngine, OH_AudioSuitePipeline** audioSuitePipeline);

/**
 * @brief Request to release the pipeline.
 *
 * @param audioSuitePipeline Reference created by OH_AudioSuiteEngine_CreatePipeline()
 * @return {@link #AUDIOSUITE_SUCCESS} if execution succeeds
 * or {@link #AUDIOSUITE_ERROR_INVALID_PARAM} if parame nullptr or not valid value.
 * @since 21
 */
OH_AudioSuite_Result OH_AudioSuiteEngine_DestroyPipeline(OH_AudioSuitePipeline* audioSuitePipeline);

/**
 * @brief Request to start the pipeline.
 *
 * @param audioSuitePipeline Reference created by OH_AudioSuiteEngine_CreatePipeline()
 * @return {@link #AUDIOSUITE_SUCCESS} if execution succeeds
 * or {@link #AUDIOSUITE_ERROR_INVALID_PARAM} if parame nullptr or not valid value.
 * @since 21
 */
OH_AudioSuite_Result OH_AudioSuiteEngine_StartPipeline(OH_AudioSuitePipeline* audioSuitePipeline);

/**
 * @brief Stop the pipeline and clear the node cache, but it will not alter the connection relationships between
 * nodes in the pipeline. Once the pipeline is stopped, no further audio processing effects can be applied.
 *
 * @param audioSuitePipeline Reference created by OH_AudioSuiteEngine_CreatePipeline()
 * @return {@link #AUDIOSUITE_SUCCESS} if execution succeeds
 * or {@link #AUDIOSUITE_ERROR_INVALID_PARAM} if parame nullptr or not valid value.
 * @since 21
 */
OH_AudioSuite_Result OH_AudioSuiteEngine_StopPipeline(OH_AudioSuitePipeline* audioSuitePipeline);

/**
 * @brief Request to get one pipeline state
 *
 * @param audioSuitePipeline Reference created by OH_AudioSuiteEngine_CreatePipeline()
 * @param pipelineState Pipeline state, which will be returned as the output parameter.
 * @return {@link #AUDIOSUITE_SUCCESS} if execution succeeds
 * or {@link #AUDIOSUITE_ERROR_INVALID_PARAM} if parame nullptr or not valid value.
 * @since 21
 */
OH_AudioSuite_Result OH_AudioSuiteEngine_GetPipelineState(
    OH_AudioSuitePipeline* audioSuitePipeline, OH_AudioSuite_PipelineState* pipelineState);

/**
 * @brief The application uses this interface for audio data rendering. frameSize represents the actual size of
 * audio frames rendered. audioData represents the rendered audio data, and processFlag indicates whether
 * all input data has been completed
 *
 * @param audioSuitePipeline Reference created by OH_AudioSuiteEngine_CreatePipeline()
 * @param audioData Audio data the pipeline processed
 * @param frameSize Audio data size
 * @param writeSize Write data size, which will be returned as the output parameter.
 * @param finishedFlag This flag is used to indicate whether all data processing has been completed.
 * @return {@link #AUDIOSUITE_SUCCESS} if execution succeeds
 * or {@link #AUDIOSUITE_ERROR_INVALID_PARAM} if parame nullptr or not valid value.
 * @since 21
 */
OH_AudioSuite_Result OH_AudioSuiteEngine_RenderFrame(OH_AudioSuitePipeline* audioSuitePipeline,
    void* audioData, int32_t frameSize, int32_t* writeSize, bool* finishedFlag);

/**
 * @brief Create a audionodebuilder can be used to create an audio node,
 * The type of audio node to be created needs to be specified,
 * with the audio node type referenced from the OH_AudioNodeType definition.
 *
 * @param builder builder Audio node builder
 * @param type Audio node type
 * @return {@link #AUDIOSUITE_SUCCESS} if execution succeeds
 * or {@link #AUDIOSUITE_ERROR_INVALID_PARAM} if parame nullptr or not valid value.
 * @since 21
 */
OH_AudioSuite_Result OH_AudioSuiteNodeBuilder_Create(OH_AudioNodeBuilder** builder, OH_AudioNode_Type type);

/**
 * @brief Destroy audio node builder.
 *
 * @param builder Reference created by OH_AudioSuiteNodeBuilder_Create()
 * @return {@link #AUDIOSUITE_SUCCESS} if execution succeeds
 * or {@link #AUDIOSUITE_ERROR_INVALID_PARAM} if parame nullptr or not valid value.
 * @since 21
 */
OH_AudioSuite_Result OH_AudioSuiteNodeBuilder_Destroy(OH_AudioNodeBuilder* builder);

/**
 * @brief Set the AudioFormat supported by the node, only nodes of input and output types support this setting.
 *
 * @param builder Reference created by OH_AudioSuiteNodeBuilder_Create()
 * @param audioFormat input node format
 * @return {@link #AUDIOSUITE_SUCCESS} if execution succeeds
 * or {@link #AUDIOSUITE_ERROR_INVALID_PARAM} if parame nullptr or not valid value.
 * @since 21
 */
OH_AudioSuite_Result OH_AudioSuiteNodeBuilder_SetFormat(OH_AudioNodeBuilder* builder, OH_AudioFormat audioFormat);

/**
 * @brief Callback function of write data.
 * The return result of this function indicates whether the data filled in the buffer is valid or invalid.
 * If result is invalid, the data filled by user will not be played.
 *
 * @param audioNode AudioNode where this callback occurs.
 * @param userData User data which is passed by user.
 * @param audioData Audio data pointer, where user should fill in audio data.
 * @param audioDataSize Size of audio data that user should fill in.
 * @param finished This boolean value indicates that all data of the application has been consumed.
 * @return Length of the valid data that has written into audioData buffer. The return value must be in range of
 * [0, audioDataSize]. If the return value is less than 0, the system changes it to 0. And, if the return value is
 * greater than audioDataSize, the system changes it to audioDataSize.
 * @since 21
 */
typedef int32_t (*OH_AudioNode_OnWriteDataCallBack)(
    OH_AudioNode* audioNode, void* userData, void* audioData, int32_t audioDataSize, bool* finished);

/**
 * @brief Set audio node write callback, Only nodes of the input type support this setting.
 *
 * @param builder Reference created by OH_AudioSuiteNodeBuilder_Create()
 * @param callback Callback to functions that will write audio data.
 * @param userData Pointer to an application data structure that will be passed to the callback functions.
 * @return {@link #AUDIOSUITE_SUCCESS} if execution succeeds
 * or {@link #AUDIOSUITE_ERROR_INVALID_PARAM} if parame nullptr or not valid value.
 * @since 21
 */
OH_AudioSuite_Result OH_AudioSuiteNodeBuilder_SetOnWriteDataCallback(
    OH_AudioNodeBuilder* builder, OH_AudioNode_OnWriteDataCallBack callback, void* userData);

/**
 * @brief Request to create audio node with audionodebuilder, the node to be created is belong to the pipeline.
 *
 * @param audioSuitePipeline Reference created by OH_AudioSuiteEngine_CreatePipeline()
 * @param builder Audio node builder created by OH_AudioSuiteNodeBuilder_Create()
 * @param audioNode Pointer to a viriable to receive the audio node
 * @return {@link #AUDIOSUITE_SUCCESS} if execution succeeds
 * or {@link #AUDIOSUITE_ERROR_INVALID_PARAM} if parame nullptr or not valid value.
 * @since 21
 */
OH_AudioSuite_Result OH_AudioSuiteEngine_CreateNode(
    OH_AudioSuitePipeline* audioSuitePipeline, OH_AudioNodeBuilder* builder, OH_AudioNode** audioNode);

/**
 * @brief Release an audio node. Whether the node can be deleted depends on the state of the pipeline it is in.
 * If the pipeline is not in the stopped state and the node is on an active processing path,
 * the operation will return that deletion is not supported.
 *
 * @param audioNode Reference created by OH_AudioSuiteEngine_CreateNode()
 * @return {@link #AUDIOSUITE_SUCCESS} if execution succeeds
 * or {@link #AUDIOSUITE_ERROR_INVALID_PARAM} if parame nullptr.
 * @since 21
 */
OH_AudioSuite_Result OH_AudioSuiteEngine_DestroyNode(OH_AudioNode* audioNode);

/**
 * @brief Request to get audio node enable status
 *
 * @param audioNode Reference created by OH_AudioSuiteEngine_CreateNode()
 * @param audioNodeEnable node enable status, which will be returned as the output parameter.
 * @return {@link #AUDIOSUITE_SUCCESS} if execution succeeds
 * or {@link #AUDIOSUITE_ERROR_INVALID_PARAM} if parame nullptr.
 * @since 21
 */
OH_AudioSuite_Result OH_AudioSuiteEngine_GetNodeEnableStatus(
    OH_AudioNode* audioNode, OH_AudioNodeEnable* audioNodeEnable);

/**
 * @brief Request to set audio enable/disable status, input node and output node can not be set enable or disable
 * this command can only be set to effect node. when one effect node is set disabled,
 * it only pull data but not process it
 *
 * @param audioNode Reference created by OH_AudioSuiteEngine_CreateNode()
 * @param audioNodeEnable enable/disable
 * @return {@link #AUDIOSUITE_SUCCESS} if execution succeeds
 * or {@link #AUDIOSUITE_ERROR_INVALID_PARAM} if parame nullptr.
 * @since 21
 */
OH_AudioSuite_Result OH_AudioSuiteEngine_EnableNode(OH_AudioNode* audioNode, OH_AudioNodeEnable audioNodeEnable);

/**
 * @brief Set the audio format for input and output nodes, specify the audio format of the audio source for
 * the input node, or specify the target audio format for the output node.
 *
 * @param audioNode Reference created by OH_AudioSuiteEngine_CreateNode()
 * @param audioFormat Audio Format
 * @return {@link #AUDIOSUITE_SUCCESS} if execution succeeds
 * or {@link #AUDIOSUITE_ERROR_INVALID_PARAM} if parame nullptr.
 * @since 21
 */
OH_AudioSuite_Result OH_AudioSuiteEngine_SetAudioFormat(OH_AudioNode* audioNode, OH_AudioFormat *audioFormat);

/**
 * @brief Executing the connect command will link two nodes in sequence, altering the topology of the pipeline. This
 * may result in partial data loss, so it is recommended to perform this command when the engine is in a stopped state.
 *
 * @param sourceAudioNode source node Reference created by OH_AudioSuiteEngine_CreateNode()
 * @param destAudioNode dest node Reference created by OH_AudioSuiteEngine_CreateNode()
 * @param sourcePortType Preceding audio out port type
 * @param destPortType dSubsequent audio node input port type
 * @return {@link #AUDIOSUITE_SUCCESS} if execution succeeds
 * or {@link #AUDIOSUITE_ERROR_INVALID_PARAM} if parame nullptr or not valid value.
 * @since 21
 */
OH_AudioSuite_Result OH_AudioSuiteEngine_ConnectNodes(OH_AudioNode* sourceAudioNode, OH_AudioNode* destAudioNode,
    OH_AudioNode_Port_Type sourcePortType, OH_AudioNode_Port_Type destPortType);

/**
 * @brief Executing the disconnect command will sever the connection between two nodes.
 * This command alters the pipeline's topology and may result in partial data loss.
 * It is recommended to perform this operation when the engine is in a stopped state.
 *
 * @param sourceAudioNode Preceding audio node Reference created by OH_AudioSuiteEngine_CreateNode()
 * @param destAudioNode Subsequent audio node Reference created by OH_AudioSuiteEngine_CreateNode()
 * @return {@link #AUDIOSUITE_SUCCESS} if execution succeeds
 * or {@link #AUDIOSUITE_ERROR_INVALID_PARAM} if parame nullptr or not valid value.
 * @since 21
 */
OH_AudioSuite_Result OH_AudioSuiteEngine_DisConnectNodes(OH_AudioNode* sourceAudioNode, OH_AudioNode* destAudioNode);

/**
 * @brief Set equalier mode of audio node.
 *
 * @param audioNode Reference created by OH_AudioSuitEngine_CreateNode()
 * @param eqMode the equalizer mode
 * @return {@link #AUDIOSUITE_SUCCESS} if execution succeeds
 * or {@link #AUDIOSUITE_ERROR_INVALID_PARAM} if parame nullptr or not valid value.
 * @since 21
 */
OH_AudioSuite_Result OH_AudioSuiteEngine_SetEqualizerMode(OH_AudioNode* audioNode, OH_EqualizerMode eqMode);

/**
 * @brief Set equalier frequency band gains of audio node.
 *
 * @param audioNode Reference created by OH_AudioSuitEngine_CreateNode()
 * @param frequencyBandGains the equalizer frequency band gains
 * @return {@link #AUDIOSUITE_SUCCESS} if execution succeeds
 * or {@link #AUDIOSUITE_ERROR_INVALID_PARAM} if parame nullptr or not valid value.
 * @since 21
 */
OH_AudioSuite_Result OH_AudioSuiteEngine_SetEqualizerFrequencyBandGains(
    OH_AudioNode* audioNode, OH_EqualizerFrequencyBandGains frequencyBandGains);

/**
 * @brief Set sound field type of audio node.
 *
 * @param audioNode Reference created by OH_AudioSuitEngine_CreateNode()
 * @param soundFieldType the sound field type
 * @return {@link #AUDIOSUITE_SUCCESS} if execution succeeds
 * or {@link #AUDIOSUITE_ERROR_INVALID_PARAM} if parame nullptr or not valid value.
 * @since 21
 */
OH_AudioSuite_Result OH_AudioSuiteEngine_SetSoundFiledType(OH_AudioNode* audioNode, OH_SoundFieldType soundFieldType);

/**
 * @brief Set environment type of audio node.
 *
 * @param audioNode Reference created by OH_AudioSuitEngine_CreateNode()
 * @param environmentType The environment type
 * @return {@link #AUDIOSUITE_SUCCESS} if execution succeeds
 * or {@link #AUDIOSUITE_ERROR_INVALID_PARAM} if parame nullptr or not valid value.
 * @since 21
 */
OH_AudioSuite_Result OH_AudioSuiteEngine_SetEnvironmentType(
    OH_AudioNode* audioNode, OH_EnvironmentType environmentType);

/**
 * @brief Set voice beautifier type of audio node.
 *
 * @param audioNode Reference created by OH_AudioSuitEngine_CreateNode()
 * @param voiceBeautifierType the voice beautifier type
 * @return {@link #AUDIOSUITE_SUCCESS} if execution succeeds
 * or {@link #AUDIOSUITE_ERROR_INVALID_PARAM} if parame nullptr or not valid value.
 * @since 21
 */
OH_AudioSuite_Result OH_AudioSuiteEngine_SetVoiceBeautifierType(
    OH_AudioNode* audioNode, OH_VoiceBeautifierType voiceBeautifierType);

/**
 * @brief Callback function of read data.
 *
 * This function pointer will point to the callback function that
 * is used to read audio data.
 *
 * @param audioNode AudioNode where this callback occurs.
 * @param userData User data which is passed by user.
 * @param audioData Audio data pointer, where user should fill in audio data.
 * @param audioDataSize Size of audio data that user should fill in.
 * @since 21
 */
typedef void (*OH_AudioNode_OnReadTapDataCallback)(
    OH_AudioNode* audioNode, void* userData, void* audioData, int32_t audioDataSize);

/**
 * @brief Install a tap on a specific out port of the node, the tap supports invoking the callback function registered
 * by the application after the node has processed the data.
 *
 * @param audioNode Audio node where this tap to install
 * @param portType Only in the specific node type of SeparationNode is it necessary to specify the out port type for
 * tap installation, in all other scenarios, this value should be set to default.
 * @param callback Callback function registered by the application to get processed audio data
 * @return {@link #AUDIOEDIT_SUCCESS} or an undesired error.
 * @since 21
 */
OH_AudioSuite_Result OH_AudioSuiteEngine_InstallTap(OH_AudioNode* audioNode, OH_AudioNode_Port_Type portType,
    OH_AudioNode_OnReadTapDataCallback callback, void* userData);

/**
 * @brief remove a tap on a specific out port of the node.
 *
 * @param audioNode Audio node where this tap to install
 * @param portType Only in the specific node type of SeparationNode is it necessary to specify the out port type for
 * tap installation, in all other scenarios, this value should be set to default.
 * @return {@link #AUDIOEDIT_SUCCESS} or an undesired error.
 * @since 21
 */
OH_AudioSuite_Result OH_AudioSuiteEngine_RemoveTap(OH_AudioNode* audioNode, OH_AudioNode_Port_Type portType);

#ifdef __cplusplus
}
#endif
/** @} */
#endif // NATIVE_AUDIO_SUITE_ENGINE_H